## Домашнее задание к лекции «Docker Compose»

Сделана конфигурация docker-compose проекта из курса по Django (CRUD: Склады и запасы).

В комплекте с проектом собраны необходимые файлы для создания 3х контейнеров: backend, postgres, nginx..  
```
docker-compose.yml - файл с описанием конфигурации для развертывания приложения 
Dockerfile с набором инструкций для образа nginx  
Dockerfile с набором инструкций для образа приложения
nginx.conf - конфигурационный файл nginx
```
Контейнеры объединяются в сеть, которые работают в связке:
```
Nginx работает в качестве proxy-http для пересылки динамических запросов к Django или возвращая статические html файлы.
PostgreSQL запускается до Django.
Django запускается через Gunicorn.
```
Инструкция  пользователя.  
За основу взято приложение (backend) [CRUD: Склады и запасы](https://github.com/Alonsole/Django_crud)  
Состав requirements - используемые библиотеки  
```
django
djangorestframework
psycopg2-binary
django-filter
gunicorn
```
Настройки приложения уже произведены и ссылаются на информацию в .env.prod  
Структура .env.prod  
```
DEBUG=0 - Режим дебага 
SECRET_KEY=Ваш секретный ключ
DJANGO_ALLOWED_HOSTS=localhost 127.0.0.1 [::1]
POSTGRES_PASSWORD=пароль для подключения к postgresql
```
Подключение к Postgresql - настройки settings.py  
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'postgres',
        'HOST': 'db',
        'PORT': '5432',
        'USER': 'postgres',
        'PASSWORD': os.environ.get('POSTGRES_PASSWORD')
    }
} 
```

Для работы с контейнерами потребуется установленный Docker.  
Подробный разбор каждой строки Dockerfile:приложения
```
FROM python:3.10-alpine - базовый образ для сборки контейнера. Используется Python версии 3.10 alpine 
(это облегченная версия, которая занимает меньше места и подходит для контейнеров)

ENV PYTHONDONTRITEBYTECODE="1" - отключает создание байт-кода при импорте модулей.
ENV PYTHONBUFFERED="1" - включает буферизацию вывода в Python
Эти две команды устанавливают переменные окружения:

WORKDIR /usr/src/app устанавливает рабочий каталог внутри контейнера.
Все последующие команды будут выполняться относительно этого каталога.

ENV APP_HOME=/usr/src/app/web - создается еще одна переменная окружения APP_HOME, 
которая указывает на подкаталог /web внутри рабочего каталога. 

RUN mkdir $APP_HOME
RUN mkdir $APP_HOME/static
Эти два шага создают директории $APP_HOME и $APP_HOME/static. 
Они нужны для размещения файлов веб-приложения и статических (static) ресурсов соответственно.

COPY ./requirements.txt ./requirements.txt -копирует файл requirements.txt из корневой директории проекта 
в текущий рабочий каталог контейнера (/usr/src/app).

RUN pip3 install -r requirements.txt -выполняет установку зависимостей Python, указанных в файле requirements.txt.

COPY . . - скопировать все файлы и папки из текущей директории проекта в рабочий каталог контейнера 
(/usr/src/app). То есть весь код приложения будет скопирован внутрь контейнера по указанному пути.

EXPOSE 8000 - команда сообщает Docker, что приложение внутри контейнера будет слушать порт 8000. 
Это не открывает сам порт автоматически, но позволяет другим сервисам обращаться к приложению через этот порт.

CMD ["gunicorn", "--bind", "0.0.0.0:8000", "stocks_products.wsgi"]

Команды, которые Docker будет выполнять при запуске контейнера. 
Здесь запускается сервер Gunicorn, который будет обслуживать ваше WSGI-приложение на всех интерфейсах (0.0.0.0) 
по порту 8000.

Dockerfile создает контейнер на основе образа Python 3.10, настраивает окружение, 
устанавливает зависимости, копирует проект и запускает сервер Gunicorn для обслуживания веб-приложения.

```
Подробный разбор каждой строки Dockerfile: nginx  
```
FROM nginx:1.26.0-alpine базовый образ для сборки контейнера. Используется nginx версии 1.26.0 alpine 
(это облегченная версия, которая занимает меньше места и подходит для контейнеров)

RUN rm /etc/nginx/conf.d/default.conf - Команда rm удаляет файл конфигурации Nginx по умолчанию, 
который находится в каталоге /etc/nginx/conf.d/. Файл обычно содержит настройки для обработки запросов 
по умолчанию, и удаление его необходимо, чтобы заменить стандартные настройки на свои собственные.

COPY nginx.conf /etc/nginx/conf.d - Команда COPY копирует файл конфигурации Nginx (nginx.conf) 
в директорию /etc/nginx/conf.d/ внутри контейнера. Вместо стандартного файла конфигурации будет созданный под 
данный проект.  

```
Подробный разбор каждой строки nginx.conf
``` 
upstream stocks_products {
    server web:8000;
}
Upstream — это блок, определяющий группу серверов, к которым Nginx будет перенаправлять запросы. 
В этом случае у нас всего один сервер, указанный как web:8000. Это означает, что Nginx будет отправлять 
запросы на хост web по порту 8000.

server {
    listen 80;
    ...
}

Блок server описывает настройки сервера, слушающего определенный порт. В данном случае сервер прослушивает 
порт 80, который является стандартным портом для HTTP-запросов.

location / {
    proxy_pass http://stocks_products;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $host;
    proxy_redirect off;
}

Блок location определяет правила обработки запросов, поступающих на определенные URL-пути. 
Все запросы, приходящие на корень сайта (/), будут обрабатываться следующим образом:

- proxy_pass http://stocks_products;: Nginx будет передавать эти запросы на upstream-сервер, 
указанный ранее (в нашем случае это web:8000).
- proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;: Добавляет заголовок X-Forwarded-For, 
содержащий IP-адрес клиента, отправившего запрос. Это полезно, когда Nginx выступает в роли обратного 
прокси-сервера.
- proxy_set_header Host $host;: Передаёт оригинальный заголовок Host от клиента на backend-сервер. 
Это важно для корректной работы приложений, зависящих от имени хоста.
- proxy_redirect off;: Отключает автоматическое изменение заголовков Location и Refresh в ответах от 
backend-сервера. Обычно это делается, чтобы избежать проблем с переадресацией.

location /static/ {
    alias /usr/src/app/web/static/;
}
Обработка статических файлов. Запросы /static/, будут обработаны непосредственно Nginx без 
передачи на приложению (backend-сервер). Файлы берутся из директории /usr/src/app/web/static/, 
указанной в строке alias*. Статические ресурсы будут доставлены быстрее, минуя промежуточную обработку 
на стороне приложения.

*alias в Nginx используется для указания альтернативного пути к файлам. Она работает аналогично директиве root, 
но имеет одно важное отличие: она добавляет путь, указанный после alias, к началу URI-запроса.
```
Файл docker-compose.prod.yml . Это файл Docker Compose, который будет содержать инструкции, необходимые 
для запуска и настройки сервисов.  

Подробный разбор каждой строки docker-compose.prod.yml  
``` 
web:
- build: ./app: образ для контейнера будет собираться из директории ./app.
- command: gunicorn --bind 0.0.0.0:8000 stocks_products.wsgi: Команда, которая выполняется при запуске 
контейнера, здесь используется Gunicorn для сервировки приложения Django, привязываясь к порту 8000.
- volumes: - ./app/:/usr/src/app/: Монтирует локальную директорию приложения в контейнер.
- - static_volume:/usr/src/app/web/static: Монтирует общий том для статики приложения.
- expose: - 8000: Позволяет другим контейнерам взаимодествовать с этим контейнером на порту 8000 
без предварительного открывания порта на хост.
- env_file: - /usr/src/.env.prod: Переменные окружения, используемые контейнером.
- depends_on: - db: Контейнер зависит от контейнера базы данных db, который должен запускаться раньше.

db:
- image: postgres:17.0-alpine: Официальный образ PostgreSQL версии 17.0 на базе Alpine.
alpine (это облегченная версия, которая занимает меньше места и подходит для контейнеров)
- volumes: - postgres_data:/var/lib/postgresql/data/: Общий том для хранения данных базы данных, 
чтобы они сохранялись между перезапусками контейнера.
- env_file: - /usr/src/.env.prod: Файл с переменными окружения для конфигурации базы данных.

nginx:
- build: ./nginx: Образ для Nginx будет собираться из директории ./nginx.
- volumes: - static_volume:/usr/src/app/web/static: Монтирует общий том для статики.
- ports: - 80:80: Пробрасывает порт 80 хоста на порт 80 контейнера.
- depends_on: - web: Контейнер зависит от контейнера web, который должен запускаться раньше.

▎Общие тома

- volumes:
- postgres_data:: Том для хранения данных PostgreSQL.
- static_volume:: Том для хранения статических файлов приложения (static).
```
Инструкция по размещению проекта:  
``` 
Необходимо создать аналогичный путь, как у проекта. 
Структура должна выглядеть так:
в корне /usr/src/
app, docker-compose.prod.yml, nginx, .env.prod

/usr/src/app
Dockerfile,  entrypoint.prod.sh,  manage.py, requirements.txt, logistic,requests-examples.http,  
stocks_products

Найстройки приложения находятся тут: /usr/src/app/stocks_products/settings.py
```
Инструкция по запуску приложения:
``` 
$ docker-compose -f docker-compose.prod.yml up -d --build
$ docker-compose -f docker-compose.prod.yml exec web python manage.py migrate --noinput
$ docker-compose -f docker-compose.prod.yml exec web python manage.py collectstatic --no-input --clear
```
Если потребуется удалить:
``` 
$ docker-compose -f docker-compose.prod.yml down -v
```
Команды выполнять находять в дериктории нахождения docker-compose.prod.yml - /usr/src/  

Проверку работоспособности:
``` 
http://localhost/admin/login/?next=/admin/ - Открыть приложение. Если всё прошло успешно и нет ошибок. 
Сайт отобразится корректно.

Файл requests-examples.http содержит примеры запросов. Для отправки рекомендую использовать Rest Client

Ссылка на APIшку - http://localhost/api/v1/
```
Если возникли проблемы:  
``` 
docker-compose logs -f - просмотр логов. 
```
Сборка произведена в WSL.  